"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const config_1 = require("../../config");
const util_1 = require("../../util");
const config = (0, config_1.readConfigSync)();
class Command {
    constructor() {
        this.command = 'synth';
        this.describe = 'Synthesizes Kubernetes manifests for all charts in your app.';
        this.aliases = ['synthesize'];
        this.builder = (args) => args
            .option('app', { default: config.app, required: true, desc: 'Command to use in order to execute cdk8s app', alias: 'a' })
            .option('output', { default: config.output, required: false, desc: 'Output directory', alias: 'o' })
            .option('stdout', { type: 'boolean', required: false, desc: 'Write synthesized manifests to STDOUT instead of the output directory', alias: 'p' });
    }
    async handler(argv) {
        const command = argv.app;
        const outdir = argv.output;
        const stdout = argv.stdout;
        if (outdir !== config.output && stdout) {
            throw new Error('\'--output\' and \'--stdout\' are mutually exclusive. Please only use one.');
        }
        await fs.remove(outdir);
        if (stdout) {
            await (0, util_1.mkdtemp)(async (tempDir) => {
                await (0, util_1.synthApp)(command, tempDir);
                const manifests = (await fs.readdir(tempDir)).filter(f => path.extname(f) === '.yaml');
                for (const f of manifests) {
                    fs.createReadStream(path.join(tempDir, f)).pipe(process.stdout);
                }
            });
        }
        else {
            await (0, util_1.synthApp)(command, outdir);
        }
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY2xpL2NtZHMvc3ludGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3Qiw2Q0FBK0I7QUFFL0IseUNBQThDO0FBQzlDLHFDQUErQztBQUUvQyxNQUFNLE1BQU0sR0FBRyxJQUFBLHVCQUFjLEdBQUUsQ0FBQztBQUVoQyxNQUFNLE9BQU87SUFBYjtRQUNrQixZQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ2xCLGFBQVEsR0FBRyw4REFBOEQsQ0FBQztRQUMxRSxZQUFPLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUV6QixZQUFPLEdBQUcsQ0FBQyxJQUFnQixFQUFFLEVBQUUsQ0FBQyxJQUFJO2FBQ2pELE1BQU0sQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSw4Q0FBOEMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUM7YUFDeEgsTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQzthQUNuRyxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSx1RUFBdUUsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQTBCdkosQ0FBQztJQXhCUSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQVM7UUFDNUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFFM0IsSUFBSSxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU0sSUFBSSxNQUFNLEVBQUU7WUFDdEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RUFBNEUsQ0FBQyxDQUFDO1NBQy9GO1FBRUQsTUFBTSxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXhCLElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxJQUFBLGNBQU8sRUFBQyxLQUFLLEVBQUMsT0FBTyxFQUFDLEVBQUU7Z0JBQzVCLE1BQU0sSUFBQSxlQUFRLEVBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUVqQyxNQUFNLFNBQVMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUM7Z0JBQ3ZGLEtBQUssTUFBTSxDQUFDLElBQUksU0FBUyxFQUFFO29CQUN6QixFQUFFLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUNqRTtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7YUFBTTtZQUNMLE1BQU0sSUFBQSxlQUFRLEVBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDO0lBQ0gsQ0FBQztDQUNGO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCAqIGFzIHlhcmdzIGZyb20gJ3lhcmdzJztcbmltcG9ydCB7IHJlYWRDb25maWdTeW5jIH0gZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IHN5bnRoQXBwLCBta2R0ZW1wIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmNvbnN0IGNvbmZpZyA9IHJlYWRDb25maWdTeW5jKCk7XG5cbmNsYXNzIENvbW1hbmQgaW1wbGVtZW50cyB5YXJncy5Db21tYW5kTW9kdWxlIHtcbiAgcHVibGljIHJlYWRvbmx5IGNvbW1hbmQgPSAnc3ludGgnO1xuICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpYmUgPSAnU3ludGhlc2l6ZXMgS3ViZXJuZXRlcyBtYW5pZmVzdHMgZm9yIGFsbCBjaGFydHMgaW4geW91ciBhcHAuJztcbiAgcHVibGljIHJlYWRvbmx5IGFsaWFzZXMgPSBbJ3N5bnRoZXNpemUnXTtcblxuICBwdWJsaWMgcmVhZG9ubHkgYnVpbGRlciA9IChhcmdzOiB5YXJncy5Bcmd2KSA9PiBhcmdzXG4gICAgLm9wdGlvbignYXBwJywgeyBkZWZhdWx0OiBjb25maWcuYXBwLCByZXF1aXJlZDogdHJ1ZSwgZGVzYzogJ0NvbW1hbmQgdG8gdXNlIGluIG9yZGVyIHRvIGV4ZWN1dGUgY2RrOHMgYXBwJywgYWxpYXM6ICdhJyB9KVxuICAgIC5vcHRpb24oJ291dHB1dCcsIHsgZGVmYXVsdDogY29uZmlnLm91dHB1dCwgcmVxdWlyZWQ6IGZhbHNlLCBkZXNjOiAnT3V0cHV0IGRpcmVjdG9yeScsIGFsaWFzOiAnbycgfSlcbiAgICAub3B0aW9uKCdzdGRvdXQnLCB7IHR5cGU6ICdib29sZWFuJywgcmVxdWlyZWQ6IGZhbHNlLCBkZXNjOiAnV3JpdGUgc3ludGhlc2l6ZWQgbWFuaWZlc3RzIHRvIFNURE9VVCBpbnN0ZWFkIG9mIHRoZSBvdXRwdXQgZGlyZWN0b3J5JywgYWxpYXM6ICdwJyB9KTtcblxuICBwdWJsaWMgYXN5bmMgaGFuZGxlcihhcmd2OiBhbnkpIHtcbiAgICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gICAgY29uc3Qgb3V0ZGlyID0gYXJndi5vdXRwdXQ7XG4gICAgY29uc3Qgc3Rkb3V0ID0gYXJndi5zdGRvdXQ7XG5cbiAgICBpZiAob3V0ZGlyICE9PSBjb25maWcub3V0cHV0ICYmIHN0ZG91dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCctLW91dHB1dFxcJyBhbmQgXFwnLS1zdGRvdXRcXCcgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gUGxlYXNlIG9ubHkgdXNlIG9uZS4nKTtcbiAgICB9XG5cbiAgICBhd2FpdCBmcy5yZW1vdmUob3V0ZGlyKTtcblxuICAgIGlmIChzdGRvdXQpIHtcbiAgICAgIGF3YWl0IG1rZHRlbXAoYXN5bmMgdGVtcERpciA9PiB7XG4gICAgICAgIGF3YWl0IHN5bnRoQXBwKGNvbW1hbmQsIHRlbXBEaXIpO1xuXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0cyA9IChhd2FpdCBmcy5yZWFkZGlyKHRlbXBEaXIpKS5maWx0ZXIoZiA9PiBwYXRoLmV4dG5hbWUoZikgPT09ICcueWFtbCcpO1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgbWFuaWZlc3RzKSB7XG4gICAgICAgICAgZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLmpvaW4odGVtcERpciwgZikpLnBpcGUocHJvY2Vzcy5zdGRvdXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgc3ludGhBcHAoY29tbWFuZCwgb3V0ZGlyKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29tbWFuZCgpO1xuIl19