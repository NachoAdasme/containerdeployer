"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsiiModule = void 0;
const os = require("os");
const path = require("path");
const logging = require("../lib/logging");
const util_1 = require("./util");
class JsiiModule {
    constructor(options) {
        this.name = options.name;
        this.moduleDirectory = options.moduleDirectory;
        this.availableTargets = options.availableTargets;
        this.outputDirectory = options.defaultOutputDirectory;
        this.dependencyNames = options.dependencyNames ?? [];
    }
    /**
     * Prepare an NPM package from this source module
     */
    async npmPack() {
        this._tarball = await util_1.Scratch.make(async (tmpdir) => {
            // Quoting (JSON-stringifying) the module directory in order to avoid
            // problems if there are spaces or other special characters in the path.
            const args = ['pack', JSON.stringify(this.moduleDirectory)];
            if (logging.level >= logging.LEVEL_VERBOSE) {
                args.push('--loglevel=verbose');
            }
            const out = await (0, util_1.shell)('npm', args, { cwd: tmpdir });
            // Take only the last line of npm pack which should contain the
            // tarball name. otherwise, there can be a lot of extra noise there
            // from scripts that emit to STDOUT.
            const lines = out.trim().split(os.EOL);
            const lastLine = lines[lines.length - 1].trim();
            if (!lastLine.endsWith('.tgz') && !lastLine.endsWith('.tar.gz')) {
                throw new Error(`npm pack did not produce tarball from ${this.moduleDirectory} into ${tmpdir} (output was ${JSON.stringify(lines)})`);
            }
            return path.resolve(tmpdir, lastLine);
        });
    }
    get tarball() {
        if (!this._tarball) {
            throw new Error('Tarball not available yet, call npmPack() first');
        }
        return this._tarball.object;
    }
    async load(system, validate = true) {
        return system
            .loadModule(this.moduleDirectory, { validate })
            .then((assembly) => (this._assembly = assembly));
    }
    get assembly() {
        if (!this._assembly) {
            throw new Error('Assembly not available yet, call load() first');
        }
        return this._assembly;
    }
    async cleanup() {
        if (this._tarball) {
            await this._tarball.cleanup();
        }
    }
}
exports.JsiiModule = JsiiModule;
//# sourceMappingURL=packaging.js.map